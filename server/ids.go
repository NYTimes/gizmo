package server

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"strings"

	uuid "github.com/nu7hatch/gouuid"
)

// IDer generates a new ID
type IDer interface {
	ID() (string, error)
}

// AppUUID generates IDs based on v4 UUIDs
type AppUUID struct {
	formatter func(string) string
}

// NewAppUUID creates a new AppUUID generator
func NewAppUUID(appname string) *AppUUID {
	return &AppUUID{
		formatter: formatter(appname),
	}
}

// ID returns a random (v4) UUID using the prefix supplied to NewAppUUID()
func (i *AppUUID) ID() (string, error) {
	u, err := uuid.NewV4()
	if err != nil {
		return "", err
	}

	return i.formatter(u.String()), nil
}

type RandB64ID struct {
	formatter func(string) string
}

// NewRandB64ID creates a new RandB64ID generator
func NewRandB64ID(appname string) *RandB64ID {
	return &RandB64ID{
		formatter: formatter(appname),
	}
}

func (i *RandB64ID) ID() (string, error) {
	var buf [12]byte
	var b64 string
	for len(b64) < 10 {
		rand.Read(buf[:])
		b64 = base64.StdEncoding.EncodeToString(buf[:])
		b64 = strings.NewReplacer("+", "", "/", "").Replace(b64)
	}

	return i.formatter(b64), nil
}

// A PipelineID identifies requests all the way through some system by concatenating the
// IDs generated by each individual app, each separated by a separator string, "|"
type PipelineID struct {
	AppIDer IDer
}

const fullIDerSep = "|"

// ID generates a new pipeline ID based on the current ID and its app IDer
func (f *PipelineID) ID(current string) (string, error) {
	next, err := f.AppIDer.ID()
	if err != nil {
		return "", err
	}

	if len(current) == 0 {
		return next, nil
	}

	return strings.Join([]string{current, next}, fullIDerSep), nil
}

func formatter(appname string) func(string) string {
	if len(appname) > 0 {
		// ...if an appname is supplied, use that instead of the default
		format := appname + "-%s"
		return func(u string) string {
			return fmt.Sprintf(format, u)
		}
	}

	return func(u string) string {
		return u
	}
}